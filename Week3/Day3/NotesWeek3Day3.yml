ðŸ“‘ Agenda for Week3Day03: TypeScript Key Features 
 
ðŸŽ¯ [Focus: Deep Dive into TypeScript's Advanced Features]  

ðŸ• Session Highlights

Recap
   - Key Takeaways from Week3. 

1. Introduction to TypeScript.
* What is TypeScript, and Why Use It?  
* Setting Up a TypeScript Environment.  
* Basic Syntax and First TypeScript Program.  

2. TypeScript Types  
* Overview of Types in TypeScript:  
* Hands-on: Declaring Variables with Different Types.  

3. Explicit Types & Annotations 
* Why Use Type Annotations?  
* Explicitly Defining Function Parameters and Return Types.  
* Examples:  
     * Type Inference vs. Explicit Types. 

6. Type Aliases  
* What are Type Aliases and why use them?  
* Syntax and examples.   
--> Breakout session Handson on Type alias. 

7. Object Literals  
* Defining and using object types in TypeScript.  

8. Type Assertion  
* What is Type Assertion?  
* Examples: Converting unknown types.  


ðŸ•¡ Wrap Up / Q&A

ðŸ“ Keep your physical notebook and pen handy to sketchÂ outÂ ideas!
-------------------------------------------------------------------------

TypeScript introduction :
-------------------------

TypeScript Installation commands:
---------------------------------

1. npm install typescript or npm install -g typescript

2. Check : tsc --version

------------------------------------------------

Note if you want directly run the .ts file follow below steps :
--------------------------------------------------------------

1. npm install -g ts-node

2. npx tsc --init --> This will create a default tsconfig.json

3. Make below changes in the tsconfig.json
{
  "compilerOptions": {
    "module": "CommonJS"
  }
}
4. Now execute the file directly using the below command

 ts-node filename.ts


 TypeScript datatypes :
 ----------------------
  Difference between "any" and "unknown"
  --------------------------------------

 âœ… any â€” â€œTurn Off TypeScriptâ€
let data: any = "Message received from the server";
data = 1234;
data = true;

data.toUpperCase();  // âœ… No error at compile time
data.push(10);       // âœ… No error
data();              // âœ… No error

ðŸ”´ Problem:

TypeScript does not check anything on any.
Even wrong operations compile successfully, and your app crashes at runtime.

So "any" means:

"I don't care about type safety."

âœ… unknown â€” â€œSafe Version of anyâ€
let value: unknown;

value = 40;
value = "Hello";

value.toUpperCase(); // âŒ ERROR (compile time)


TypeScript blocks you here because:

"I don't know what type this is yet."

Now we check:

if (typeof value === "string") {
    console.log(value.toUpperCase()); âœ… Allowed
}


âœ… Now TypeScript knows it is a string.
âœ… You proved the type â€” so it allows safe operations.

--------------------------------------------------------------

never datatype :
----------------

âœ… In Playwright, never is used for functions that permanently stop a test when a critical failure happens.

Example :

import { test, expect } from "@playwright/test";

// A function that always stops the test

function stopTest(message: string): never {
    throw new Error(message);  // âŒ Test execution stops here
}

test("Login test with never example", async ({ page }) => {

    await page.goto("http://leaftaps.com/opentaps/control/main");

    const title = await page.title();

    if (title !== "Login") { // when the title value is false 
        stopTest("Login page did not load correctly"); // âœ… never
    }

    // âœ… This line runs ONLY if the title is correct
    console.log("Test continues safely...");
});

-------------------------------------------------------------------


 Classroom activity on union type :
 ------------------------------------

- Create a function that accepts only specific payment methods.

- Create a type alias called PaymentMethod that allows only "UPI", "CreditCard", or "PayPal".

- Write a function makePayment that takes a parameter of type PaymentMethod and prints which payment method is chosen.

- Call the function with "UPI" and "CreditCard"Â asÂ arguments.

--------------------------------------------------------------------------

enum :
 ------------------------------------
- Enums are a way to define a set of named constants, making your code more readable and maintainable.


Think of enum like a menu in a restaurant:

Instead of customers shouting random dish names, they choose from the menu (fixed options).

The menu items are the named constants (e.g., Menu.Pizza, Menu.Burger).

You canâ€™t order something not on the menu (compilerÂ error).