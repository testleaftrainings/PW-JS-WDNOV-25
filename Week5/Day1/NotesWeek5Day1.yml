ğŸ“‘ Agenda for Week 5 Day 1: Advanced Data Parameterization using CSV and ENV

ğŸ¯ [Focus: Advanced Data Parameterization]  

ğŸ“† Date: 22 December [Monday]  

ğŸ• Session Highlights

â¿¡ Recap
* Quick review of key learnings from previous sessions. 

1. *Reading CSV Files*  
* Importing and parsing CSV test data.   
* Best practices for maintaining test data files.

2. *Reading ENV Files*  
* Importing and parsing ENV test data.   
* Best practices for maintaining test data files. 

ğŸ•¡ Wrap Up / Q&A  

ğŸ“ Keep your physical notebook and pen handy to sketchÂ outÂ ideas!


# Data Parameterization with CSV
---
### **Definition**
CSV --> Comma Seperated Values.

Reading test data from CSV files and running tests with multiple data sets.
CSV is widely used in organizations for bulk test data (rows = test cases, columns = input fields).

Usage
1. Sample CSV (testData.csv):

tcid,username,password
1,demoSalesManager,crmsfa
2,demoCSR,crmsfa

Step 1:
Install csv : command - 
npm install csv-parse.

Step 2:
Create a .csv file under Data folder.

Step 3:
Create a .spec.ts and import data from csv file similar to the sample script.

Step 3:
Use the imported data in your test cases for validation.  

Step 4:
Run the test to see data-driven testing in action.

***************************************************************


// /* 
// Before conversion in CSV :

// tcid,username,password
// 1,demoSalesmanager,crmsfa
// 2,demoCSR,crmsfa

// After conversion in JSON csv-parse converts CSV rows into objects, like this:

//    [
//      { 
//       tcid:1,
//       username: "demoSalesManager", 
//       password: "crmsfa" 
//       },
//      { tcid:2,
//       username: "demoCSR", 
//       password: "crmsfa" 
//       }
//    ]



# Data Parameterization with ENV
---
### **Definition**

A .env file (short for environment file) is a simple text file used to store environment variables in the form of key-value pairs.

It is commonly used in projects to separate configuration data (like URLs, API keys, database credentials, secrets) from the actual application code.

Usage
1. Sample ENV (config.env): 
APP_URL=https://example.com
USERNAME=demoUser
PASSWORD=securePass123


Step 1:
Install dotenv : command - 
npm install dotenv
Step 2:
Create a .env file under Data folder.
Step 3:
Create a .spec.ts and import data from env file similar to the sample script. 
Step 4:
Use the imported data in your test cases for validation.
Step 5:
Run the test to see data-driven testing in action.

-----------------------------------------------------------------------

ğŸ”¹ Different types of imports in JS / TS

There are two main ways to import something:

1ï¸âƒ£ Default import
import fs from "fs";

2ï¸âƒ£ Named import
import { parse } from "csv-parse/sync";

ğŸ”¹ Why fs does NOT use { }?
âœ… Because fs is a DEFAULT EXPORT

The Node.js fs module exports one main object (the whole file system API).

So you import the entire module as a single object:

import fs from "fs";


ğŸ‘‰ fs now contains:

fs.readFileSync
fs.writeFileSync
fs.existsSync
fs.mkdirSync
...


You access methods using dot notation:

fs.readFileSync("data.csv");

ğŸ”¹ Why parse DOES use { }?
âœ… Because parse is a NAMED EXPORT

The csv-parse/sync module exports specific functions, one of which is parse.

So you must destructure it:

import { parse } from "csv-parse/sync";


ğŸ‘‰ You are saying:

â€œGive me only the parse function from this moduleâ€

Usage:

const records = parse(csvData);

ğŸ”¹ Think of it like a real-life example ğŸ§ 
ğŸ“¦ Module as a Box
fs module:
ğŸ“¦ fs
 â”œâ”€â”€ readFileSync
 â”œâ”€â”€ writeFileSync
 â”œâ”€â”€ unlinkSync
 â””â”€â”€ ...


You take the whole box:

import fs from "fs";

csv-parse/sync module:
ğŸ“¦ csv-parse
 â”œâ”€â”€ parse
 â”œâ”€â”€ stringify
 â””â”€â”€ ...


You take only one item from the box:

import { parse } from "csv-parse/sync";

ğŸ”¹ Can fs be imported with {}?

âŒ This will NOT work:

import { fs } from "fs"; // âŒ WRONG


But âœ… this will work:

import { readFileSync } from "fs";


Because readFileSync is a named export.

ğŸ”¹ Summary Table ğŸ“Œ
Import Style	Syntax	When to Use
Default Import	import fs from "fs"	When module exports ONE main object
Named Import	import { parse } from "csv-parse/sync"	When module exports multiple named items
ğŸ”¹ Relating to Playwright (easy to remember)
import test from "@playwright/test";   // default export
import { expect } from "@playwright/test"; // named export