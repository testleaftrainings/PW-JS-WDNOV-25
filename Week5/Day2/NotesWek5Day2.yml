üìë Agenda for Week 5 Day 2: Advanced Playwright Interactions
üéØ Focus: Exploring Advanced Features for Enhanced Playwright Automation

üìÜ Date: 23 Dec [Tuesday]

‚ø° Test Annotations // Annotation - Hooks

* Enhancing test readability and control using annotations.
* Examples: Skipping, focusing specific tests.

‚ø¶  Persistent Context (Non-incognito mode)

* Maintaining login/session state across test runs using user data directories.
* Real-world example: Avoid repeated logins for authenticated flows.

‚ø£  Geolocation

* Simulating geolocation data for location-based testing.
* Practical use cases: Testing location-restricted functionalities.


‚ø§ Device Emulation

* Emulating various devices and screen resolutions in Playwright.
* Practical examples: Testing responsive designs and mobile-specific features.

‚ø• Visual Regression Testing

* Capturing and comparing UI snapshots to detect unintended changes.
* Use cases: Ensuring consistent UI across versions and devices.


Other Test Annotation
---

test.only --> focus on a specific test.
test.skip --> ignore the test from execution
test.fixme --> track and know failures that are yet tp be fixed
test.fail --> for negative testing --> test has to fail is the expectation
test.slow --> triple the timeout of the tests execution --> 30 s --> 60 s for the entire test execution
test.describe --> grouping the test depending on the status of the other test.
test.use -->use the functionalities




//Purpose of visual regression testing :
//1. Detect unintended UI changes in web applications.
//2. Ensure consistent appearance across different browsers and devices.
//3. Practical examples: Catching layout shifts, color changes, or missing elements.  

//Purpose of geolocation :
//1. Simulating geolocation data for location-based testing.
//2. Testing location-restricted functionalities.
//3. Practical use cases: Testing location-restricted functionalities.
//4. Example: Testing location-restricted functionalities.



//Purpose of device emulation :
//1. Testing responsive designs and mobile-specific features.
//2. Simulating various devices and screen resolutions in Playwright.
//3. Practical examples: Testing responsive designs and mobile-specific features.


Persistent Context (Non-incognito mode) :
--- 
//1. Maintain login/session state across test runs.
//2. Real-world example: Avoid repeated logins for authenticated flows.
//3. Useful for debugging with consistent state across sessions.
//4. Store user preferences and settings persistently.
//5. Usage of user data directory to store the session data.
//6. Example code snippet to launch browser with user data directory:
//   const context = await browserType.launchPersistentContext(userDataDir, options);
//7. Benefits: Faster test execution, reduced redundancy in authentication steps.


Difference between Storage State and Persistent Context :
---

//1. Storage State saves session data to a file, while Persistent Context uses a user data directory.
//2. Storage State is loaded into a new context, whereas Persistent Context maintains state across sessions
//3. Storage State is useful for sharing session data, while Persistent Context is ideal for long-term state persistence.
//4. Storage State requires manual saving/loading, while Persistent Context automatically manages state.
//5. Storage State is typically used for temporary session management, while Persistent Context is used for ongoing sessions.
//6. Example of Storage State: context.storageState({ path: 'state.json' });
//7. Example of Persistent Context: browserType.launchPersistentContext(userDataDir, options);




**************************************************************************************

```ts
import { test, expect } from "@playwright/test";

/**
 * =========================
 * test.skip()
 * =========================
 * Purpose:
 * - Do NOT execute the test at all
 * - Used when environment / feature is NOT ready
 */
test.skip('Skip when environment is not ready', async ({ page }) => {
  await page.goto('http://leaftaps.com/opentaps/control/main');

  await page.locator('#username').fill('democsr');
  await page.locator('#password').fill('crmsfa');
  await page.locator('.decorativeSubmit').click();
  await page.locator('text=CRM/SFA').click();
});


/**
 * =========================
 * test.fixme()
 * =========================
 * Purpose:
 * - Test is known to be broken or flaky
 * - Acts as a reminder to FIX later
 * - Test will be skipped, but marked as "needs fixing"
 */
test.fixme('Test is under repair / flaky', async ({ page }) => {
  await page.goto('http://leaftaps.com/opentaps/control/main');

  await page.locator('#username').fill('democsr');
  await page.locator('#password').fill('crmsfa');
  await page.locator('.decorativeSubmit').click();
  await page.locator('text=CRM/SFA').click();
});


/**
 * =========================
 * test.fail()
 * =========================
 * Purpose:
 * - Test WILL run
 * - Failure is EXPECTED due to a known bug
 * - Failure will NOT break CI
 */
test.fail('Known bug: CRM link not visible', async ({ page }) => {
  await page.goto('http://leaftaps.com/opentaps/control/main');

  await page.locator('#username').fill('democsr');
  await page.locator('#password').fill('crmsfa');
  await page.locator('.decorativeSubmit').click();

  // Known issue: locator fails
  await expect(page.locator('text=CRM/SFA')).toBeVisible();
});


/**
 * =========================
 * test.slow()
 * =========================
 * Purpose:
 * - Mark test as slow
 * - Doubles the default timeout
 */
test('Slow test example (timeout increased)', async ({ page }) => {

  test.slow(); // increases timeout (approx 2x default)

  await page.goto('http://leaftaps.com/opentaps/control/main');

  await page.locator('#username').fill('democsr');
  await page.locator('#password').fill('crmsfa');

  await page.locator('.decorativeSubmit').click();

  await page.locator('text=CRM/SFA').click();
});
```

---

##  Simple Explanation 

###  `test.skip()`

>  Don‚Äôt run this test at all

* Used when:

  * Environment is down
  * Feature not implemented
* Result in report: **Skipped**

---

###  `test.fixme()`

>  This test is broken ‚Äì fix it later

* Same as skip
* But tells the **team**:

  > ‚ÄúThis test needs fixing‚Äù
* Very useful for flaky tests

---

###  `test.fail()`

>  Run the test, but failure is expected

* Test **executes**
* If it fails ‚Üí ‚úî expected
* If it passes ‚Üí ‚ö† unexpected (bug may be fixed!)

---

###  `test.slow()`

>  This test needs more time

* Increases timeout
* Useful for:

  * Slow APIs
  * Heavy pages
  * Large uploads/downloads

---

##  Quick Memory Table

| Annotation   | Runs? | Purpose                         |
| ------------ | ----- | ------------------------------- |
| `test.skip`  | ‚ùå No  | Environment / feature not ready |
| `test.fixme` | ‚ùå No  | Broken / flaky test             |
| `test.fail`  | ‚úÖ Yes | Known bug                       |
| `test.slow`  | ‚úÖ Yes | Needs more time                 |

