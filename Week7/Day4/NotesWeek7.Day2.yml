ðŸ“‘ Agenda for Week 9 Day 4: Custom Fixture

ðŸŽ¯ Focus: Mastering Object-Oriented Programming Concepts in TypeScript

ðŸ“† 13th Jan, Tuesday

ðŸ• Session Highlights

â¿¡ Recap
Quick review of previous learnings.

1. Custom Fixture
Creating reusable test setup using custom fixtures.
Examples: Injecting test data, context, or utilities.

2. Abstraction
Using abstract classes and methods to define templates.
Examples: Designing partially implemented base classes.


ðŸ•¡ Wrap Up / Q\&A

ðŸ“ Keep your physical notebook and pen handy to sketch out ideas andÂ testÂ workflows!


Custom Fixture :
----------------

# Playwright Custom Fixture â€“

## What problem is Custom Fixture solving?

=> In real projects, **every test needs login**
=> Writing login steps in **every test** is:

* Repetitive 
* Hard to maintain 
* Not professional 

âœ… **Solution:** Use a **custom fixture**

---

##What is a Fixture (Simple words)

> A **fixture** is **pre-written setup code** that runs **before your test starts**,and **cleanup code** that runs **after your test ends**.

---

## Your Custom Fixture File (02-fixture.ts)

import { test as baseT } from "@playwright/test";

export const test = baseT.extend({

### What is happening here?

* `baseT` â†’ Original Playwright test
* `extend()` â†’ We are **adding our own behavior**
* We are **overriding the `page` fixture**

---

## The Custom `page` Fixture

page: async ({ browser }, use) => {

### Meaning:

* Playwright gives us a **browser**
* We create our **own page**
* We control **when test starts and ends**

---

## Setup Phase (Runs BEFORE the test)

const page = await browser.newPage()
await page.goto(`http://leaftaps.com/opentaps/control/main`)

âœ” Browser opens
âœ” Page opens
âœ” Application launches

---

### Login Steps (Reusable logic)

await page.locator(`#username`).fill(`demosalesmanager`);
await page.locator(`#password`).fill(`crmsfa`);
await page.locator(`.decorativeSubmit`).click();

âœ” Login is completed
âœ” Now page is in **logged-in state**

---

## The MOST IMPORTANT LINE

await use(page)

### MUST REMEMBER

> **`use(page)` is the border line**

### What it means:

| Before `use(page)` | After `use(page)` |
| ------------------ | ----------------- |
| Setup code         | Cleanup code      |
| Runs BEFORE test   | Runs AFTER test   |

Think of it as:

> â€œOkay Playwright, now give this page to the testâ€

---

## Cleanup Phase (Runs AFTER the test)

await page.close()

âœ” Page closed
âœ” Browser cleaned
âœ” No memory leak

This happens **automatically after test execution**

---

## Your Test File

import { test } from "./02-fixture";


### Why not import from `@playwright/test`?

ðŸ‘‰ Because we want:

* Logged-in page
* Pre-configured page
* Reusable setup

---

### Test Code

test(`Using Custom Fixture`, async ({ page }) => {
    console.log(await page.title());
});


### What happens here?

* Page is **already logged in**
* Test does **NOT know login logic**
* Test focuses only on **validation**

ðŸ“Œ Output:

Leaftaps - TestLeaf Automation Platform
---

## Execution Flow (VERY IMPORTANT)

Fixture START
  â”œâ”€ Browser opens
  â”œâ”€ Page opens
  â”œâ”€ App launches
  â”œâ”€ Login happens
  â”œâ”€ use(page) â† Test starts here
      â””â”€ Test prints title
  â”œâ”€ Test ends
  â”œâ”€ page.close()
Fixture END
```

---

## Why This Is INDUSTRY STANDARD

âœ… Clean code
âœ… Reusable
âœ… Scalable
âœ… Easy maintenance
âœ… Interview-ready concept

---



---

## One-line Interview Answer

> **Custom fixture is used to centralize common setup and teardown logic so that tests remain clean, reusable, and maintainable.**



1. Interface :
-----------------

- Complete hiding of the implemented.
- 100% abstraction.
- Only unimplemented methods.

Summarize 

- class extends another class
- abstract extends another abstract class
- interface extends another interface
- class extends abstract class
- class implements interface
- class extends abstract class im plemnets interface

We cannot see implementation of your page fixture, context browser in playwright everytging is put in as interface

2. Abstraction
----------------- 

abstract class :

- 0 to 100% abstraction.
- Method signature --> unimplementedmethods
- Implemented methods --> logic 


